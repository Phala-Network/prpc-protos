
syntax = "proto3";

import "google/protobuf/empty.proto";

package pruntime_rpc;

// The greeting service definition.
service PhactoryAPI {
  // Get basic information about Phactory state.
  rpc GetInfo (google.protobuf.Empty) returns (PhactoryInfo) {}

  // Sync the parent chain header
  rpc SyncHeader (HeadersToSync) returns (SyncedTo) {}

  // Sync the parachain header
  rpc SyncParaHeader (ParaHeadersToSync) returns (SyncedTo) {}

  // Dispatch blocks (Sync storage changes)
  rpc DispatchBlocks (Blocks) returns (SyncedTo) {}

  // Init the Phactory runtime
  rpc InitRuntime (InitRuntimeRequest) returns (InitRuntimeResponse) {}

  // Get the cached Phactory runtime init response
  rpc GetRuntimeInfo (google.protobuf.Empty) returns (InitRuntimeResponse) {}

  // Get pending egress messages
  rpc GetEgressMessages (google.protobuf.Empty) returns (GetEgressMessagesResponse) {}
}

// Basic information about a Phactory instance.
message PhactoryInfo {
  // Whether the init_runtime has been called successfully.
  bool initialized = 1;
  // Whether the worker has been registered on-chain.
  bool registered = 2;
  // Genesis block header hash passed in by init_runtime.
  optional string genesis_block_hash = 4;
  // Public key of the worker.
  optional string public_key = 5;
  // ECDH public key of the worker.
  optional string ecdh_public_key = 6;
  // The relaychain/solochain header number synchronized to.
  uint32 headernum = 7;
  // The parachain header number synchronized to. (parachain mode only)
  uint32 para_headernum = 8;
  // The changes block number synchronized to.
  uint32 blocknum = 9;
  // Current chain storage's state root.
  string state_root = 10;
  // Whether the worker is running in dev mode.
  bool dev_mode = 11;
  // The number of mq messages in the egress queue.
  uint64 pending_messages = 12;
  // Local estimated benchmark score.
  uint64 score = 13;
  // Status of gatekeeper
  GatekeeperStatus gatekeeper = 14;
}

enum GatekeeperRole {
  None = 0;
  Dummy = 1;
  Active = 2;
}

message GatekeeperStatus {
  // The Gatekeeper role of the worker.
  GatekeeperRole role = 1;
  // The master public key, empty if not a Gatekeeper
  string master_public_key = 2;
}

// Response to SyncHeader & SyncParaHeader.
message SyncedTo {
  // The final actual block number synced to.
  uint32 synced_to = 1;
}

// Request parameters for SyncHeader.
message HeadersToSync {
  // The relaychain headers to be synced.
  // @codec scale crate::blocks::HeadersToSync
  bytes headers = 1;
  // @codec scale crate::blocks::AuthoritySetChange
  optional bytes authority_set_change = 2;
}

// Request parameters for SyncParaHeader.
message ParaHeadersToSync {
  // The parachain headers to be synced.
  // @codec scale crate::blocks::Headers
  bytes headers = 1;
  // aka StorageProof
  repeated bytes proof = 2;
}

// Request parameters for DispatchBlocks.
message Blocks {
  // The blocks to be synced.
  // @codec scale Vec<crate::blocks::BlockHeaderWithChanges>
  bytes blocks = 1;
}

// Request parameters for InitRuntime.
message InitRuntimeRequest {
  // Skip the remote attestation report.
  bool skip_ra = 1;
  // Genesis block infomation for light validation.
  // @codec scale crate::blocks::GenesisBlockInfo
  bytes genesis_info = 2;
  // Worker identity key for dev mode.
  optional bytes debug_set_key = 3;
  // The parachain's genesis storage state.
  // @codec scale crate::blocks::StorageState
  bytes genesis_state = 4;
  // The operator of of this worker, which has the permission to bind it's miner.
  // @codec scale chain::AccountId
  optional bytes operator = 5;
  // Init the runtime for parachain.
  bool is_parachain = 6;
}

message InitRuntimeResponse {
  // @codec scale phala_types::WorkerRegistrationInfo<chain::AccountId>
  bytes runtime_info = 1;
  // The hash of the first synced relaychain header.
  // @codec scale chain::Hash
  bytes genesis_block_hash = 2;
  // The worker's public key.
  // @codec scale phala_types::WorkerPublicKey
  bytes public_key = 3;
  // @codec scale phala_types::EcdhPublicKey
  bytes ecdh_public_key = 4;
  // The sgx attestation
  optional Attestation attestation = 5;
}

message Attestation {
  int32 version = 1;
  string provider = 2;
  AttestationReport payload = 3;
  uint64 timestamp = 4;
}

message AttestationReport {
  string report = 1;
  bytes signature = 2;
  bytes signing_cert = 3;
}

// Response for GetEgressMessages
message GetEgressMessagesResponse {
  // @codec scale EgressMessages
  bytes messages = 1;
}
